import re
import random
import ast
import operator
import difflib
from ollama import Client

client = Client(
    host='127.0.0.1:11435',
)




def compute_score(solution_str, ground_truth, method='strict', format_score=0.1, score=1.):
    """The scoring function for countdown task.
    
    Args:
        solution_str: The solution string generated by the model
        ground_truth: The ground truth solution string. eg. "双相情感障碍"
        method: The scoring method to use. Options: 'strict', 'format'
        format_score: The score to give if the solution is correctly formatted
        score: The score to give if the solution is correct
        
    Returns:
        The score for the solution
    """
    target = ground_truth['medication']
    target_medications = re.split(',|，| ', target)
    patient_info = ground_truth['patient_info']
    solution_str = "<think>" + solution_str


    do_print = random.randint(1, 8) == 1
    
    if do_print:
        print(f"--------------------------------")
        print(f"Target: {target} | Patient_info: {patient_info[:100]}")
        print(f"Solution string: {solution_str}")

    # reward 评估内容包含：1. 输出格式是否符合规范。2. 最终的诊断结果是否正确。3. 
    
    # 判断输出格式是否符合规范，即 <think>...</think> <answer>...</answer>
    think_part = ""
    answer_part = ""
    output_format_score = 0
    output_medication_score = 0
    output_readability_score = 0
    try:
        think_part = re.findall(r"<think>(.*?)</think>", solution_str, re.DOTALL)
        answer_part = re.findall(r"<answer>(.*?)</answer>", solution_str, re.DOTALL)

        if len(re.findall(r"<think>", solution_str, re.DOTALL)) > 1 or len(re.findall(r"</think>", solution_str, re.DOTALL)) > 1 or len(re.findall(r"<think>", solution_str, re.DOTALL)) > 1 or len(re.findall(r"</think>", solution_str, re.DOTALL)) > 1:
            print(f"Output format wrong")
            output_format_score += -2
        
        if len(think_part) == 1 and len(answer_part) == 1:
            print(f"Output format correct")
            output_format_score += 1
        # else:
        #     print(f"Output format wrong")
        #     output_format_score += -2
    except:
        print(f"Output format wrong")
        output_format_score += -1
        return -3
    
    final_think = "".join(think_part)
    final_answer = "".join(answer_part)

    if final_think == "" or final_answer == "":
        print(f"Output completely wrong")
        return -3

    # 对answer部分的输出长度过长施加惩罚
    # if len(final_answer) > 40:
    #     output_format_score += -0.5

    # 对anwer部分后面又继续输出内容施加惩罚
    if len(solution_str.split('</answer>')) > 1 and len(solution_str.split('</answer>')[1]) > 20:
        print(f"Output still after </answer>")
        output_format_score += -1

    # 对think部分中出现的关键词进行奖励
    # 一般的诊断标准包括：症状，病程，严重程度，排除。所以如果think中出现了这些关键字，则可以为其施加奖励
    # 对于一些体现思维过程的关键词也施加一定的奖励，如首先，其次，然后，但是等。
    reward_keywords1 = ['症状', '诊断', '既往史', '治疗史', '合并', '副作用']
    if any(kw in final_think for kw in reward_keywords1):
        output_format_score += len([kw for kw in reward_keywords1 if kw in final_think])*0.1
    
    
    # reward_keywords2 = ['首先', '其次', '然后', '但是', '鉴于']
    # if any(kw in final_think for kw in reward_keywords1):
    #     output_format_score += 0.1

    # 对think部分中出现的胡言乱语的现象进行惩罚
    # 观察到的具体现象有：输出一大段没有标点符号且没有逻辑的话，可以通过给两个标点符号之间的长度施加惩罚
    matches_between_punc = re.findall(r'[.,;!?。，、？！:：”“ ](.*?)(?=[.,;!?。，、？！:：”“ ])', final_think)
    for match in matches_between_punc:
        if len(match) > 80:
            print(f"Too long sentence: {match}")
            output_format_score += -0.5
            break
    
    # 尝试通过和参考答案计算相似度，对相似度过低的答案施加较大惩罚，来约束模型不要胡言乱语。只施加惩罚，不施加奖励
    
    

    if len(final_think) > 1000:
        instruction = f"""请判断下面这段分析推理性文字是逻辑通顺的，还是逻辑不通的。如果不通顺则输出0，如果通顺则输出1，不要输出任何其他内容。待判断文字：
{final_think}"""
        
        response = client.chat(model='qwen2.5:3b', messages=[
            {
                'role': 'user',
                'content': instruction
            },
        ],
        
        # options = {"temperature":0.1}
        )
        readability = response['message']['content']
        if '0' in readability:
            print(f"Too poor readability:{readability}")
            output_readability_score += -1
        elif '1' in readability:
            print(f"Good readability:{readability}")
            output_readability_score += 1
    
    # if difflib.SequenceMatcher(None, reference, final_think).ratio() > 0.5:
    #     print(f"Good readability:{readability}")
    #     output_readability_score += 0.5

    


    # 判断最终诊断结果是否正确
    # 由于模型输出的诊断结果和标准答案术语可能存在差异，但含义一致，所以需要给这种情况施加一定的奖励
    # 首先根据ICD编码进行判断
    suggested_medications_list = re.split(',|，| ', final_answer)
    suggested_medications_set = set(suggested_medications_list)
    if len(suggested_medications_list) != len(suggested_medications_set):
        output_medication_score += -1

    for drug in suggested_medications_set:
        if drug in target_medications:
            output_medication_score += 2/len(target_medications)
        elif drug not in target_medications:
            output_medication_score += -2/len(target_medications)
    
    # if len(suggested_medications) == len(target_medications):
    #     output_medication_score += 0.3
    if len(suggested_medications_set) == 0:
        output_medication_score += -0.2




    
    final_score = output_medication_score + output_format_score + output_readability_score
    print("=="*50)
    print(f"Format Score: {output_format_score}, Readability Score: {output_readability_score}, Medication Score: {output_medication_score}, Final Score: {final_score}")
    print("=="*50)
    return final_score
    
# score = compute_score("我认为诊断结果应该是偏执型人格障碍", {'diagnosis': "双相情感障碍，目前为缓解状态"}, method='strict', format_score=0.1, score=1.)

# print(score)